#!/bin/sh

# ----------------------------------------------------------------------
# dev_ops run_profile tool 'rp', (c) 2014, Mikkel Fahnøe Jørgensen,
# mikkel@dvide.com, license: MIT
# ----------------------------------------------------------------------
#
# Loads environment key/values from multiple sources and runs a tool of
# choice within the isolated environment of that tool. It also provides
# a structure for storing specific files such as SSH keys that differ in
# different scenarios (different profiles and systems).
#
# The tool is intended to load access and encryption keys into a devops
# tool like Ansible, cloud host provider libraries such as python boto
# for AWS, or simply to use ssh more conveniently on multiple different
# host systems.
#
# It is especially useful to help separate system configuration from
# user specific configuration where only the system configuration is
# under shared source control, and it makes it easy to switch between
# heterogenous systems such as multiple cloud hosting providers, or
# datacenters.
# 
# This tool is no way tied to any particular other tool, but to
# exemplify: Ansible easily handles different setups, but, assuming the
# playbook rules are written as generic as possible, it still needs to
# be told which configuration to use, and then have the right access
# keys to do the job.
#
# See 'rp --help' for brief description or 'rp --doc' for detailed
# description.


# TODO:
#
# add DEVOPS_PROFILE_LOCK and DEVOPS_SYSTEM_LOCK
# If either value is set, they must both be set and match.
#
# Examples could be:
# DEVOPS_PROFILE_LOCK=megacorp-aws-eu-west-2014-09-alpha-0.0.4
# DEVOPS_PROFILE_LOCK=98bdb4c8f5e014dfca6b1640c894f9c3
#
# it cannot be read from the environment or from the command line.  It
# is not secret, or safe, it mere avoids unintentional mismatches.
#
# It can also be used to quickly disable all profiles centrally until
# further action can be taken by updating the DEVOPS_SYSTEM_LOCK.
#
# Semantic versioning with softer match rules may also be worth
# considering, but probably overkill.
#
# --force can be used to override.

name=$(basename $0)

function usage {
    echo "Usage: ${name} [-options] [<command> [<args> ...]]"
    echo "     : ${name} --help | -h"
    echo ""
    echo "    <command> : system command or shell script, defaults to 'env'"
    echo "    <args>    : arbitrary arguments to <command>"
    echo ""
    echo "Runs command with a given environment profile."
cat <<EOF

Options:

    -p | --profile[=]<profile>
            override DEVOPS_PROFILE

    -s | --system[=]<system>
            override DEVOPS_SYSTEM

    -e | --export
            expands and exports .env files with '[<basename>]' as separator
            (commands are not alloved)

    -n | --no-expand
            disables template expansion
            implies -e

    -x | --no-headers
            disables section headers in export
            implies -e
        
    -o | --output[=]<file> 
            implies -e but writes to specified file

    -f | --force
            ignore missing directory errors

    -v | --verbose
            debug information

    -h | --help
            brief help message

    -d | --doc
            a long version of the help message
EOF
}

function brief {
usage
cat <<EOF

Reads key/value pairs from the following files (default paths):

    ~/.devops/profiles/<profile>/profile.env
    ./systems/<system>/system.env

The .env format is roughly:

    # comment - no leading spaces are allowed.
    MY_SETTING="my value"
    Valid=no
    MY_FILE={{ profile_home }}/myfile.conf

The values are exported into the environment of the command being
called. Note that the following will not work:

    $ rp echo "$MY_SETTING"

but the following will:

    $ rp eval "echo \$MY_SETTING"
    my value
or
    $ rp sh
    echo "$MY_SETTING"
    exit

The profile environment does not exists before or after the call.

<system> and <profile> are optional, and may also be given in the
environment, but command line arguments will override these.

The default paths without the above settings are:

    ~/.devops/profiles/profile.env
    ./systems/system.env

Both files are read in that order when present, but none are required.
Without .env files, certain paths are still exposed to the environment
which may be used to locate other configuration files.
EOF
}

function help {
    echo "$(brief)\n\nMore help with: ${name} --help"
    exit 0
}

function fail {
    usage >&2 
    echo $1 >&2
    exit 1; 
}

function document {
    echo "$(brief)\n\n\n" | cat - $(dirname $0)/run-profile-help 
    exit 0
}



# ----------------------------------------------------------------------
# opt-in option pre-parser library, (c) 2014, Mikkel Fahnøe Jørgensen
# Version: v0.1.0, License: MIT
# ----------------------------------------------------------------------
function _opt_dbg { [ $_opt_dbg_enabled -ne 0 ] && echo "debug: $@"; }
function _opt_esc { _opt_ping="'\''"; _opt_qv="${1//\'/$_opt_ping}"; _opt_qv="'${_opt_qv}'"; }
function _opt_push { _opt_dbg "pushing: $@";
    for _opt_i; do _opt_esc "$_opt_i"; _opt_args="${_opt_args}${_opt_qv} "; done; } 
function _opt_value { _opt_dbg _value_; _opt_push "$1"; unset _opt_expect; unset _opt_missing; }
function opt_user_fail { reason="$1"; name="$2"; msg="$3";
    echo >&2 "$msg $name"; exit 1; }
function opt_missing { _opt_dbg _missing_;
    _opt_value "${1:-${_opt_missing:-$_opt_tmissing}}";
    [ $_opt_silent -eq 0 ] && \
        opt_user_fail "missing-value" "$_opt_expect" "error: option expected a value: "; }
function _opt_put {
    if [ -n "$_opt_expect" ]; then [ $_opt_eager -ne 0 ] && _opt_dbg "_eager_" && \
        _opt_value "$_opt_token" && return 0;
        _opt_dbg "_strict_default_"; opt_missing; fi;
    _opt_dbg "_type_: $1"; _opt_push "$2"; [ -n "$3" ] && _opt_value "$3"; }
function opt_invalid { _opt_brk=1;
    _opt_put "i: invalid option" "${1:-$_opt_tinvalid}" "$_opt_token";
    [ $_opt_silent -eq 0 ] &&  \
        opt_user_fail "invalid-option" "$_opt_token" "error: invalid option: "; }
function opt_kv { _opt_put "kv: key value" "$1" "${_opt_token#*=}"; }
function opt_ev { _opt_missing="$2"; _opt_put "ev: expect value option" "$1";
    _opt_expect="$_opt_token"; } 
function opt_v { _opt_put "v: value option"  "$1" "${_opt_token:2}"; }
function opt_vg { _opt_put "vg: value given option"  "$1" "$2"; }
function opt_vs { _opt_put "vs: value suffix" "$1" "${_opt_token#$2}"; }
function opt_f { _opt_put "f: flag option" "$1"; }
function opt_break { [ -n "$_opt_expect" ] && _opt_dbg _break_expecting_ && opt_missing;
    [ $_opt_brk -eq 0 ] && [ -n "$1" ] && _opt_dbg _break_ && _opt_push "$1"; _opt_brk=1; }
function opt_nonopt { opt_break "$1"; _opt_dbg _nonopt_; _opt_push "$_opt_token"; }
function opt_pos { _opt_dbg _pos_; [ -n "$_opt_expect" ] && _opt_value "$_opt_token" \
    || opt_nonopt "$1"; }
function opt_resume { _opt_brk=0; _opt_dbg _resume_; }
function opt_next { _opt_token="$1"; OPT_TOKEN="$1";
    _opt_dbg "args so far: $_opt_args"; _opt_dbg "next token: $1";
    if [ $_opt_brk -eq 0 ]; then return 0; else opt_pos; return 1; fi; }
function opt_debug { echo >&2 "opt: token='$_opt_token'"; }
function opt_init { _opt_args=""; _opt_token=""; _opt_qv=""; 
    _opt_brk=0; unset _opt_expect; unset OPT_ARGS; _opt_silent=0; _opt_eager=1;
    _opt_tinvalid='?'; _opt_tmissing=':'; _opt_dbg_enabled=0;
    for _opt_i; do _opt_dbg _opt_init_ arg "$_opt_i"
        case "$_opt_i" in silent) _opt_silent=1;; eager) _opt_eager=1;;
    strict) _opt_eager=0;; noisy) _opt_silent=0;; debug) _opt_dbg_enabled=1;;
    invalid=*) _opt_tinvalid=${_opt_i#*=};; missing=*) _opt_tmissing=${_opt_i#*=};;
    *) echo >&2 "error: opt-in opt_init: invalid argument: $_opt_i";; esac; done; }
function opt_final { 
    [ -z "$_opt_expect" ] || opt_missing;
    OPT_ARGS="${_opt_args%?}"; OPT_IN="eval set -- $OPT_ARGS"; _opt_dbg "OPT_ARGS: $OPT_ARGS"
   unset _opt_args; unset _opt_token; unset _opt_qv; unset _opt_silent;unset _opt_debug_enabled;
    unset opt_i; unset _opt_brk; unset _opt_expect; unset _opt_missing; unset OPT_TOKEN;
    unset _opt_eager; unset _opt_tmissing; unset _opt_tinvaild; unset _opt_ping; }
# ------------------------- end opt-in library -------------------------

# customize opt_in error handler
function opt_user_fail {
    reason=$1; name=$2; msg=$3;
    fail "$msg $name"
}

opt_init debug strict #missing=42 invalid=43
for arg
do
    if opt_next "$arg"; then
    case "$arg" in

       -d|--doc) opt_f -d ;;
       -e|--export) opt_f -e ;;
       -f|--force) opt_f -f ;;
       -h|--help) opt_f -h ;;
       -n|--no-headers) opt_f -n  ;;
       -v|--verbose) opt_f -v ;; 
       -x|--no-expand) opt_f -x ;;

       -o|--output) opt_ev -o ;;
       -p|--profile) opt_ev -p ;;
       -s|--system) opt_ev -s ;;

       # may also hold empty accepted value
       -o=*|--output=*) opt_kv -o ;;
       -p=*|--profile=*) opt_kv -p ;;
       -s=*|--system=*) opt_kv -s ;;

       -o*) opt_v -o ;;
       -p*) opt_v -p ;;
       -s*) opt_v -s ;;

       # enable these if needed, otherwise they will fail as unpexected
       --) opt_break -- ;; 
       #-) opt_f -;

       -*) opt_invalid ;;
       # pass on all other values - these are values, or post option arguments
       # may also pass a quoted empty value; a -- is inserted before first
       # non-option.
       *) opt_pos -- ;; 
    esac
    fi
done
opt_final

echo "args before long translation:\n$@"
# put the translated arguments back on the input
$OPT_IN
echo "args after long translation:\n$@"

    echo "arg list:"
    for arg
    do
        echo $arg
    done
    echo "end arg list."


# Now do a program specific parse.
# The follwoing will work without the former, but only
# for simple short options like:
#
#    $ rp -h -o <filename> -e -s <system> -p <profiile>
#
# We still keep it tight and keep application logic out, except
# handling implied options. We allow for empty value detection.


# Reset all variables that might be set

unset e_arg
unset f_arg
unset n_arg
unset v_arg
unset x_arg
unset o_arg
unset p_arg
unset s_arg

o_val=""
p_val=""
s_val=""

# STDIN (-)
unset stdin_arg
# (--) split operator
unset split_arg

function check_arg {
    if [ $1 -eq 1 ] && ( [ "$2" == ":" ] || [ -z "$2" ] ) ; then
        echo $3;
        echo "aborting."
        exit 1;
    fi
}


while [ -n "$1" ]
do
    echo "parsing opts"
    case $1 in
        -d)  document;;
        -e)  e_arg=1;;
        -f)  f_arg=1;;
        -h)  help;;
        -n)  n_arg=1; e_arg=1;;
        -v)  v_arg=1;;
        -x)  x_arg=1; e_arg=1;;
        -o)  o_arg=1; o_val=$2; shift;;
        -p)  p_arg=1; p_val=$2; shift;;
        -s)  s_arg=1; s_val=$2; shift;;
        -)   stdin_arg=1;;
        --)  shift; echo "-- break"; break;;
        '?')  echo "invalid option: $2"; shift; break;;
        *) echo "unexpected: '$1'" ;; #fail "internal: unexpected option or command";;
    esac
    shift
done

echo "END OF TEST"
exit

# TODO: the following does not parse correctly:
#  echo "\ _"
#  echo "\ "
#  echo ".\ ."

echo "args left: $@"
echo "done testing args"
echo "system: $sarg"
exit

# Now the options are fully parsed and the input
# arguments that remain will start with $1.
# cmd_arg will have been set if we got any
# and split_arg will have been set if -- was used.

# Finally pass on the values to application logic.

# TODO: deal with empty values for p, s, and o args.
OVERRIDE_DEVOPS_PROFILE=$p_arg
OVERRIDE_DEVOPS_SYSTEM=$s_arg
DEVOPS_DEBUG=$v_arg
DEVOPS_EXPORT=$e_arg
DEVOPS_OUTPUT=$o_val
DEVOPS_NOEXPAND=$n_arg
DEVOPS_NOHEADERS=$x_arg
DEVOPS_FORCE=$f_arg

# parse args : http://stackoverflow.com/a/24121652
# we cannot use this directly - we must stop at a command and fail at unknown option
# then collect the remains for the subcommand - but it is nice base.

#TODO:
echo >&2 "warning: option parsing not yet solid"

OVERRIDE_DEVOPS_PROFILE=${DEVOPS_PROFILE}
OVERRIDE_DEVOPS_SYSTEM=${DEVOPS_SYSTEM}

# missing command, or unknown option
if [ -z "$1" ]; then
    CMD=env
else
    if [ ! $DEVOPS_EXPORT ]; then
        CMD=$@
    else
        fail "command not allowed with any export option: $1"
    fi
fi

# this method is Posix compliant.
command -v $1 >/dev/null 2>&1 || fail "error: command not found: $1"

trace "loading profile"
source `dirname $0`/load-profile

if [ ! $DEVOPS_EXPORT ]; then
    $CMD
fi

