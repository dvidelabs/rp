#!/bin/sh
VERSION=0.1.4
NAME="rp (run-profile)"

set -e

# CHANGELOG
# 0.1.4
#    * give project bin dirs precedence over global commands
#      as they often tend to conflict: e.g. script to ping
#      or login to remote host.
#      Add short option -g for global command, rename
#      --exclude-bin to --global.
#    * fix unexpected handler to fail properly
#   
#
# 0.1.3
#    * add help description with command prompt example.
#    * add system specific bin directory.
#    * use {{ system_root }}/bin instead of {{ project_home }}/bin
#      so rp dependent scripts are kept separate from main scripts.
#
# 0.1.2
#    * {{ project_home }} substitution supported.
#      {{ project_home }}/bin added to executable path by default. 
#
# 0.1.1
#    * fix arg parsing bug
#    * add support for .devops.conf for finding systems directory
#
# 0.1.0
#    * initial release


# ----------------------------------------------------------------------
# dev_ops run_profile tool 'rp', (c) 2014, Mikkel Fahnøe Jørgensen,
# mikkel@dvide.com, license: MIT
# ----------------------------------------------------------------------
#
# Loads environment key/values from multiple sources and runs a tool of
# choice within the isolated environment of that tool. It also provides
# a structure for storing specific files such as SSH keys that differ in
# different scenarios (different profiles and systems).
#
# The tool is intended to load access and encryption keys into a devops
# tool like Ansible, cloud host provider libraries such as python boto
# for AWS, or simply to use ssh more conveniently on multiple different
# host systems.
#
# It is especially useful to help separate system configuration from
# user specific configuration where only the system configuration is
# under shared source control, and it makes it easy to switch between
# heterogenous systems such as multiple cloud hosting providers, or
# datacenters.
# 
# This tool is no way tied to any particular other tool, but to
# exemplify: Ansible easily handles different setups, but, assuming the
# playbook rules are written as generic as possible, it still needs to
# be told which configuration to use, and then have the right access
# keys to do the job.
#
# See 'rp --help' for brief description or 'rp --doc' for detailed
# description.


# Possible extension:
#
# add DEVOPS_PROFILE_LOCK and DEVOPS_SYSTEM_LOCK
# If either value is set, they must both be set and match.
#
# Examples could be:
# DEVOPS_PROFILE_LOCK=megacorp-aws-eu-west-2014-09-alpha-0.0.4
# DEVOPS_PROFILE_LOCK=98bdb4c8f5e014dfca6b1640c894f9c3
#
# it cannot be read from the environment or from the command line.  It
# is not secret, or safe, it mere avoids unintentional mismatches.
#
# It can also be used to quickly disable all profiles centrally until
# further action can be taken by updating the DEVOPS_SYSTEM_LOCK.
#
# Semantic versioning with softer match rules may also be worth
# considering, but probably overkill.
#
# --force can be used to override.

appname=$(basename $0)

function usage {
cat <<EOF
Usage: ${appname} [-options] [<command> [<args> ...]]
     : ${appname} --help | -h

    <command> : system command or shell script, defaults to 'env'
    <args>    : arbitrary arguments to <command>

Runs command with a given environment profile.

Options:

    -p | --profile[=]<profile>
            override DEVOPS_PROFILE

    -s | --system[=]<system>
            override DEVOPS_SYSTEM

    -e | --export
            expands and exports .env files with '[<basename>]' as separator

    -n | --no-expand
            disables template expansion
            implies -e

    -x | --no-headers
            disables section headers in export
            implies -e
        
    -o | --output[=]<file> 
            implies -e but writes to specified file

    -f | --force
            ignore missing directory errors

    -t | --trace
            debug information
            
    -v | --version
            version of this tool

    -h | --help
            brief help message

    -d | --doc
            a long version of the help message

    -g | --global
            exclude {{ system_home }}/bin:{{ system_root }}/bin from executable path

    --init
            creates .devops.conf and systems/common_system.env files

EOF
}

function brief {
usage
cat <<EOF

Reads key/value pairs from the following files (default paths):

    ~/.devops/profiles/<profile>/profile.env
    ./systems/<system>/system.env

The .env format is roughly:

    # comment - no leading spaces are allowed.
    # a value is everything after '=' until end of line
    # with trailing spaces stripped.
    MY_SETTING=my value
    Valid=no
    MY_FILE={{ profile_home }}/myfile.conf

The values are exported into the environment of the command being
called. Note that the following will not work:

    $ rp echo "\$MY_SETTING"

but the following will:

    $ rp eval "echo \$MY_SETTING"
    my value
or
    $ rp sh
    echo "\$MY_SETTING"
    exit

The profile environment does not exists before or after the call.

<system> and <profile> are optional, and may also be given in the
environment, but command line arguments will override these.

Both files are read in that order when present, but none are required.
Without .env files, certain paths are still exposed to the environment
which may be used to locate other configuration files.

The default paths without the above settings are:

    {{ profile_root }}/profiles/profile.env
    {{ project_home }}/systems/system.env

Where {{ profile_root }} defaults to '~/.devops', and {{ project_home }}
is the current directory unless

    .devops.conf

is found in a parent directory, which then becomes the project home.
Currently the file is not read, it is just an anchor. It can be created
with 'rp --init' and normally .devops.conf should be added to source
control.

Profiles SHOULD NOT be added to source control, they hold
personal secrets and are kept separate for that reason.

When a command is run, the global system PATH environment is used as
usual, but PATH is by default extended with

    {{ system_home }}/bin:{{ system_root }}/bin

for both the current command, and any command executed indirectly.
This is useful for running various scripts as part of the tooling -
especially because small wrapper scripts are often needed to take
advantage of the environment variables made available. The system
specific bin directory is useful for things like:

    rp publish

Which might only make sense for a web site or blog system.

The entire environment can be frozen in a sub-shell like:

    rp bash

or, for example:

    rp --profile joe/aws1 bash

You probably want to update your prompt, for example in .bashrc for OS X:

    PS1='\[\e[0;33m\]\u\[\e[0m\]@\[\e[0;32m\]\h\[\e[0m\]:\[\e[0;34m\]\w\[\e[0m\]\\$ '
    if [ -n "\$DEVOPS_PROFILE" ]; then
        # set prompt for subshell
        PS1="\e[0;32m\][\$DEVOPS_PROFILE]\[\e[0m\]:\[\e[0;34m\]\w\[\e[0m\]\\$ "
    fi

All secrets are exposed in the subshell, but also, all scripts can be run
at native speeds in the current path, even when outside the project directory.
This trades convenience for safety and potential confusion.

EOF
# NOTE: in the prompt above, '$' has been escaped with '\$' remove the '\' in
# the .bashrc if reading this in the source file.
}

function help {
    echo "$(brief)\n\nMore help with: rp --doc | less"
    exit 0
}

function fail {
    usage >&2 
    echo $1 >&2
    exit 1; 
}

# ----------------------------------------------------------------------
# Very long documentation here, code follows below, such that we can
# have one file that is easily deployed in a devops/dir without much
# install fuzz.
# ----------------------------------------------------------------------

function document {
    echo "$(brief)\n\n\n";
    cat << __ENDDOC__
Introduction to the 'rp' or 'run-profile' tool
======================================================================

The 'rp' tool works a bit similar to the 'env' tool be setting up
a customized environment before running a command.


Installation
------------

The 'rp' file should be executable and placed in an executable path
such as '/usr/local/bin'.

Currently there are some associated files that must be located in the
same directory. These are named: 'run-profile*'.

It can also be copied directly into, say, ./bin of devops repository
and run as 'bin/rp'. The user specific setup evolves around
configuring ~/.devops/profiles - this is discussed at length below.


Use Case
--------

A typical (simplified) use case could be to give AWS_SECRET_KEY and
friends to the python boto library, give network topology to ansible,
give ssh.config to ssh while allowing for multiple system
configurations and multiple possible user profiles, making core
deployment scripts reusable.


Motivation
----------

It is convenient to write a few scripts to lauch a tool in different
configurations. For example ssh into different cloud providers are
using ansible roles in different contexts. This in itself can quickly
explode into many unmaintable scripts, even if using a very structured
approach such as ansible overall.

Furthermore, some data such as host IP addresses may need frequent
and expedient synchronization across teams by using a source code
repository such as git, while other data such
user account data does belong there, and may provide a security risk.

Even when these user specific data are separated out, the lack of
structure and standardization makes it difficult to set up a
consistent framework and typically requires a lot of written
instructions and easily broken scripts.

In the end, a job needs to done, and the end result may be that data
are hacked into the wrong places, which then easily leads to the other
meaning of the word hacked as critical data are exposed in hosted
source code repositories.

Using this tool will not solve all problems, but it becomes easier to
structure things right, for example by documenting that a user profile
must define "SSH_PRIVATE_KEY" and have it point to a valid key. This
can then by done by dropping the key into the profile home and store
the name without being concerned with global path conventions. Here
is an arbitrary example:

    $ cat ~/.devops/profiles/examples/dc01/profile.env

    # copy to ~/.devops/profiles/<myname>/dc01
    # log in to management console to get key and credentials
    # fill in below...
    
    SSH_PRIVATE_KEY={{ profile_home }}/mykey.pem


    # IMPORTANT: only set this to yes if you need to maintain system:
    # dc-polar/bonzai with database backup jobs (TODO: we need to
    # clean this up and create a new system config with the proper
    # setting).
    # FIXME_SSH_FORWARD_AGENT=yes
    FIXME_SSH_FORWARD_AGENT=no

    # Remove this for internal datacenters such as dc-tribal and dc-polar 
    AWS_SECRET_KEY=...
    AWS_ACCESS_KEY=...
    AWS_REGION=...
    
    # This must be a valid path in trainee-devops/systems:
    DEVOPS_SYSTEM=aws/test-01
    # DEVOPS_SYSTEM=polar-bonzai


By sharing an example profile or a tree of such, documentation
requirements are kept to a minimum, and users can update their own
credentials as they change or become available.

The user of the above might then run:

    $ cp -r ~/.devops/profiles/examples/dc01 ~/.devops/profiles/doe/test-dc01
    (edit and add key)
    $ cd trainee-devops
    $ ls systems
    aws/
    polar-bonazai

    $ rp -p doe/test-dc01 ansible -m ping all

    (systems/aws/test-01/system.env would have settings needed by ansible)


Setup
-----

Before running a configuration management (or any other) tool, the
environment must be setup.

Tools using this setup will load the environment with items such as
secret keys and also choose the associated system configuration just
before running the tool Thus, keys are not lingering in the shell
environment, and are kept in a single controlled location outside of
shared source repositories.

We thus have two configuration parts: systems and profiles.

The systems define network topology, service provider, firewall rules
etc.  The profiles define access credentials and customized tooling
options. Often there a profile close match one system, and thus a
system is selected by selecting a profile.

Profiles are stored outside of the primary devops source control
system and holds access keys and local encryption keys. Ideally, the
profile can be reconstructed using two factor login to a management
console to retrieve access keys, define them in a small profile.env
file and define which system the keys apply to - and possibly an ssh
key and encryption key shared by gpg email or similar, but of course
it depends.

Systems are defined inside devops repositories and may by synchronized
very frequently, for example changing the number of load-balanced web
servers.  Perhaps some settings are encrypted - we might for example
want to hide the IP of our primary access hosts, but that depends on
the tooling used.

In the basic form, we have

    ~/.devops/profiles/profile.env

or, if DEVOPS_PROFILE=dc01_shared (as an example)

    ~/.devops/profiles/dc01_shared/profile.env

or

    ~/.devops/profiles/user-doe/dc01_test/profile.env

Here DEVOPS_PROFILE_ROOT defaults to '~/.devops/profiles', and in the
exampels, DEVOPS_PROFILE was one of

    DEVOPS_PROFILE=""
    DEVOPS_PROFILE=dc01_shared
    DEVOPS_PROFILE=user-doe/dc01_test

We can override the profile root path so we find the profile with

    $DEVOPS_PROFILE_ROOT/$DEVOPS_PROFILE/profile.env

The file $DEVOPS_PROFILE_ROOT/common_profile.env is optionally read
first and may be used to select the currently active profile by
defining DEVOPS_PROFILE.

As an example, profile.env may hold tool and system specific
credentials such as:

    AWS_SECRET_KEY=xxx
    AWS_ACCESS_KEY=xxx
    AWS_REGION=xxx

Variables are entirely specific to the system tool chain, the python
boto library seems to take a preference for the above. The DEVOPS_
prefix is reserved for our environment setup use.

With the profile configured, a system can be identified. This is
normally a directory in a checked out configuration management system
and decoupled from the profile, but this is merely a convention:

After 'profile.env' has been read, 'system.env' is read (when present)
in the path:

    $DEVOPS_SYSTEM_ROOT/$DEVOPS_SYSTEM/system.env

with the system root path default to './systems' and the system
defaults to empty, so we the default path becomes:

    ./systems/system.env

Like with profiles, if a common_profile.env file is found in the
system root, it is read first, and may be used to select the active
system.  For example, we might have the following files read in that
order:

    ~/.devops/profiles/common_profile.env
    ~/.devops/profiles/dc01_shared/profile.env
    ./systems/common_system.env
    ./systems/datacenter_01/system.env

NOTE: this order allows for critical security parameters to be
confidently set in the systems.env setting regardless of what
individual users define in their profile or environment. This could,
as an example, be shutting off an SSH_FORWARD_AGENT setting that was
previously configured in user profiles. If the opposite order is
needed, use different names and deal with it in a script using
'OPTION_X=${PROFILE_X:-SYSTEM_X}'.

More generally we have:

    $DEVOPS_PROFILE_ROOT/common_profile.env
    $DEVOPS_PROFILE_ROOT/$DEVOPS_PROFILE/profile.env
    $DEVOPS_SYSTEM_ROOT/common_system.env
    $DEVOPS_SYSTEM_HOME/$DEVOPS_SYSTEM/system.env

with

    DEVOPS_PROFILE_HOME=
        $DEVOPS_PROFILE_ROOT/$DEVOPS_PROFILE

    DEVOPS_SYSTEM_HOME=
        $DEVOPS_SYSTEM_ROOT/$DEVOPS_SYSTEM

If a value is defined in multiple places, the last value read will
win, except the following specific variables take precedence from the
command line arguments, then from the existing environment:

    DEVOPS_PROFILE_ROOT
    DEVOPS_PROFILE
    DEVOPS_SYSTEM_ROOT
    DEVOPS_SYSTEM

Defaults summary:

    DEVOPS_PROFILE_ROOT=~/.devops/profiles
    DEVOPS_SYSTEM_ROOT=./systems

The following variables are temporarily overwritten, or rewritten with
absolute paths when running the command given: 

    DEVOPS_PROFILE_ROOT
    DEVOPS_SYSTEM_ROOT
    DEVOPS_PROFILE_HOME
    DEVOPS_SYSTEM_HOME

These values are also avaible to some of the .env files as template
arguments; for example {{ system_home }} is available to 'system.env'.
See support matrix below.

All .env files are always only looked up in exactly one place each,
and skipped when absent.

Both the profile and system directories may contain additional setup
files, and the .env files may be used to identify these with the
help of template arguments.


Example
-------

Lets run an example with the python boto library on OS-X to list
hosts on the AWS cluster.

    $ easy_install pip
    $ pip install boto
    (possibly also set up a python path)

Now the tool 'list_instances' should be able to list stopped and
running AWS EC2 instances, except we have to define a number of
AWS keys first.

We edit common_profile.env for a quick test:

    $ cat ~/.devops/profiles/common_profile.env
    AWS_SECRET_KEY=xxx
    AWS_ACCESS_KEY=xxx
    AWS_REGION=xxx
    DEVOPS_SYSTEM=aws/test

We can now do:

    $ rp list_instances

Notably without AWS_SECRET_KEY floating around in your shell
environment.

So far this only details the profile part. But we also wants an
ssh.config file that can be shared in a devops repository with
quickly chaning host names so we can easily log in. This is not
suitable for the profiles directory which we keep private.

Without going into specifics about ssh, we create a devops repository,
using git or similar. For simplicity we assume we operate from the
root of this repository and add the systems subdirectory:

    $ mkdir -p devops/systems/aws/test
    $ cd devops
    $ touch systems/aws/test/ssh.config
    $ touch systems/aws/test/system.env

Edit ssh.config to your specifics.
Edit system.env so we get:
    
    $ cat systems/test/system.env
    SSH_CONFIG={{ system_home }}/ssh.config
    SSH_PRIVATE_KEY={{ profile_home }}/key.pem
    
Copy you ssh key in place so we have:

    $ ls ~/.devops/profiles/
    common_profile.env
    key.pem

And finally we create a login script in ./bin/login

    $ cat ./bin/login 
    #!/bin/sh
    ssh-add $SSH_PRIVATE_KEY
    ssh -f $SSH_CONFIG $1

Note that we use ssh-add so ssh.config might use ForwardAgent=yes if
necessary. The script can be enhanced to deregister they key from the
agent when done.

Assuming ssh.config lists a host named 'test-server-01' we login wit:

    $ rp bin/login test-server-01

As an excercise, rename the common_profile.env to profile.env and
place it in a profile named 'test-01' in 'devops', and another named
'production' using a different key.  With that configured, and
ssh.config updated, we can now do:

    $ rp --profile test-01 bin/login test-server-01
    $ rp --profile production bin/login production-host

Set up a new AWS account with a new profile. This requires a new
systems dir 'aws/2', and a new profile to hold the AWS keys. With that
configured, we can name the new profile 'admin-02' that sets
DEVOPS_SYSTEM=aws/2.

    $ rp -p admin-02 list_instances
    $ rp -p test-01 list_instances

Next steps:

Use a tool like Ansible and call it with a shell script that feeds
--extra-vars with a file from $DEVOPS_SYSTEM_HOME, and possible
configures an encryption key given in the profile.env file.

Assuming we have a basic ansible setup

Finally, create a third system aws/lock-down which uses the same
account so we can reuse keys and profile, but change some ssh.config
parameters, and perhaps later some firewall rules. We also add
a hosts file for use with ansible.

Gotcha:

    $ rp -p admin-02 -s aws/3 ansible \
        -i $DEVOPS_SYSTEM_HOME/hosts -m ping all

Note that we avoid variable expansion on the command line where they
are not defined, and that run has added its own location to the
executable path temporarily.

We can work around this by placing the command in a shell script,
but since this is an ad-hoc job, we can work around it with:

    $ rp -p admin-02 -s aws/3 -i systems/aws/3/hosts -m ping all

For ad-hoc testing we can also drop into a sub-shell:

    $ rp -p admin-2 -s aws-3 bash

(advanced user might want to change the prompt at the same time)

All the secrets exposed, but we can run all commands directly:

    $ ansible -i $DEVOPS_SYSTEM_HOME/hosts -m ping all
    ...
    
and exit when done with ad-hoc testing

    $ exit

To get a more concise workflow, still with flexible profiles
we add a wrapper script for key tasks such as ansible-playbook:

    $ cat bin/play
    #!/bin/sh

    ansible-playbook -i ${DEVOPS_SYSTEM_HOME}/hosts "$@" \
        --extra-vars="@${DEVOPS_SYSTEM_HOME}/vault/vars.yml

    $ ls roles
    myplay.yml

    $ rp bin/play roles/myplay.yml
    $ rp -p test bin/play roles/myplay.yml
    ...

where the vault encryption key might have been set in the user profile
to protect the system configuration. The "$@" is shell speak for
passing the arguments from run to ansible-playbook.


Evaluation Order
----------------

The following values are decided as .env files are being read
and cannot be changed once decided. The table lists the places
they can be defined, and the first place to set it, wins.

    DEVOPS_PROFILE_ROOT    <env>
    DEVOPS_PROFILE         <arg>, <env>, <common_profile.env>
    DEVOPS_SYSTEM_ROOT     <env>, <common_profile.env>, <profile.env>
    DEVOPS_SYSTEM          <arg>, <env>, <all other env files>

Where <env> is the existing shell environment and <arg> is a command
line option given the 'rp' tool, such as '--system=mystem'.

To see have this works, use the debug facilities:

    $ rp -d
    $ rp -d -e

Other values may be set repeatedly, and the last value will win,
which gives predictability, but isn't very useful when looking up
which profile or system to use.

The behavior of other DEVOPS_ variables are reserved for future use.

The values:

    DEVOPS_PROFILE_HOME
    DEVOPS_SYSTEM_HOME

are derived from the above and can never be set.

Note that:j;w

    $ rp --system=online-services sh

will start a new shell with the profiled environment. Therefore, if
the 'rp' tool is used again, it will inherit the settings from the
parent call, which can be very useful, but when it is not, the
following example shows different ways to override settings:

    $ unset DEVOPS_PROFILE_ROOT
    $ DEVOPS_SYSTEM_ROOT=../staging rp --profile=test


File Syntax
-----------

The file consists of blank lines, comments and key value pairs:

    # Comment
       # comment

    Key=Value
    sentence_1=More than { on e word
    login_file={{ profile_home }}/login.sh

Blank lines, and comments are ignored.
Keys must start at the beginning of the line.

Comments cannot appear on key=value lines - they would be part of
the value. This allows for passwords containing special characters.

Trailing space is stripped from values, but otherwise they can
contain spaces and special characters. If you have a file name
with a trailing space, or a password, you have to define your
delimiter and strip it later, or store the value in a file.

Template arguments are mustache and Jinja2 style. The convention
is one space before and after keyword. Unsupported template
arguments are passed through.


Template Arguments
------------------

Each .env file may access a few variables when they do not define
the values within their own file:

    variable                valid for 
    -------------------------------------------------------
    {{ project_home }}      all
    {{ profile_root }}      common_profile.env, profile.env
    {{ profile_home }}      profile.env
    {{ profile }}           profile.env
    {{ system_root }}       common_system.env, system.env  
    {{ system_home }}       system.env
    {{ system }}            system.env

No other template arguments are allowed - they are passed unchanged.

Don't confuse {{ project_home }} with {{ profile_home }}. The project
home is the current directory unless a parent directory contains the
file `.devops.conf` in which case that directory becomes the project
directory. Various default paths rely on the project home path. Like
all home paths, the project home path is computed and cannot be changed.

The reason why systems do not see profiles is to separate concerns and
ease maintenance. Tools have access to all paths via the environment.

Sometimes it useful to have shared settings across systems or
profiles. In that case one can use the root paths, or the more
fragile home paths such as:

    AWS_SHARED_VARS_1={{ system_home }}/../shared.vars
    AWS_SHARED_VARS_2={{ system_root }}/aws/shared.vars


The .env files have no leading space and consists of lines of key
value pairs.  Blank lines and lines starting with # (only at line
start), are valid and ignored. Variables have exactly one space before
and after the name.

    # this is a comment

    DEVOPS_SYSTEM=datacenter_01
    DEVOPS_USER_NAME="Shared Devops User"
    DEVOPS_PROFILE=dc01_shared
    SSH_PRIVATE_KEY={{ profile_home }}/{{ profile }}/dc01_shared.pem
    SSH_DEFAULT_PRIVATE_KEY={{ profile_home }}/shared.pem

    # end of example

The convention says one space before the keyword such as {{
profile_home }}, by spaces are ignored. During export (see below)
without expansion, template arguments are rewritten with exactly
one space on either side of the keyword, making it easier to parse.


SSH Agent
---------

This is not strictly related to this tool, but it is mentioned as it
is closely related. For example in the choise of where to put keys
and whether key paths should be configured at all.

SSH keys are normally, or at least sometimes, expected to be added to
ssh agent, and configuration management systems may forward keys to
remote hosts via ssh ForwardAgent=yes. Therefore it makes sense to
password protect keys even when remote systems cannot have access
to that password. On OS-X one can add keys to the keychain with:

    $ ssh-add -K mykey.pem 

and in general without -K to add it to the running ssh-agent during
local login.  Some tools may script this using the variables such as
in the above.


rcm and git for profiles
------------------------

As a final note, the profile directory structure is designed to be
compatible with the rcm tool:

    github.com/thoughtbot/rcm

rcm synchronizes dot dirs across machines for different users and
system types, but it is not necessarily recommended unless the
security implications of multiple key locations are well understood.
Note that 'man' pages are currently the best source of documentation
for that tool.

We may also define a git repository with only example profiles and
explicitly .gitignore the actual profiles. This makes it easy to share
configuration templates, and changes to those, in relative safety.


Default Command
---------------

If no command argument is given, 'env' is called to dump the profiled
environment, unless an export option is given.

In this way it is easy to find, say, a db password:

    $ rp -p backup | grep DB_PASSWORD
    DB_PASSWORD=not-secret-anymore

or the AWS key setup:

    $ rp | grep AWS_
    AWS_ACCESS_KEY=...
    AWS_SECRET_KEY=...
    AWS_REGION=...


Export
------

It is possible to export values from the various sources. The output
is in ini style format, but is easily converted to a shell source
that will read the same environment as rp configures.

If any export option is used, it is not valid to supply a command. No
environment will be created during export.

Here is an example:


    $ rp -p doe/production-dc01 -e
    [common_profile.env]
    DEVOPS_PROFILE=doe/test-dc01
    
    [profile.env]
    AWS_ACCESS_KEY=...
    AWS_SECRET_KEY=...
    AWS_REGION=...
    SSH_PRIVATE=...../doedc01key.pem
    DEVOPS_SYSTEM=dc01/production

    [system.env]
    SYS_STATUS=TEST

    [meta]
    DEVOPS_PROFILE_ROOT=/home/doe/.devops/profiles
    DEVOPS_PROFILE_HOME=/home/doe/.devops/profiles/doe/production-dc01
    DEVOPS_PROFILE=doe/production-dc01
    DEVOPS_SYSTEM_ROOT=/home/doe/devopswork/dcx-project/systems
    DEVOPS_SYSTEM_HOME=/home/doe/devopswork/\
        dcx-project/systems/dc01/production
    DEVOPS_SYSTEM=dc01/producion

The last [meta] section is the actual settings used, regardless of
source. Here we have used the command line to override the
DEVOPS_PROFILE in common_profile.env. Also note that the
[common_system.env] section is absent because in this case there
were no such file.

The format is stripped for comments and blank lines and have exactly
one blank line between sections.

The section headers and blank lines can be stripped with:

    $ rp -x

This is almost enough to use as a shell source file, but special
characters are not escaped.

Output can also be directed to a file with the -o option, and this
option implies the -e, so we can have:

    $ rp -o "myenv.ini"
    $ rp -x -o "myenv.sh"

Last, but not least, we can disable template expansion which is useful
for sharing and reviewing configurations, but of course, mask
sensitive data first.

The following example only shows a few lines where relevant:

    $ rp -n
    [profile.env]
    ...
    SSH_PRIVATE={{ profile_home }}/keys/doedc01key.pem
    ...

    [meta]
    DEVOPS_PROFILE_ROOT={{ profile_root }}
    DEVOPS_PROFILE_HOME={{ profile_home }}
    DEVOPS_PROFILE=doe/production-dc01
    DEVOPS_SYSTEM_ROOT={{ system_root }}
    DEVOPS_SYSTEM_HOME={{ system_home }}
    DEVOPS_SYSTEM=dc01/producion


__ENDDOC__

    exit 0
}

# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
# opt-in core option parser library, (c) 2014, Mikkel Fahnøe Jørgensen
# Version: v0.1.1, License: MIT
# ----------------------------------------------------------------------
function _opt_dbg { [ $_opt_dbg_enabled -ne 0 ] && echo "debug: $@"; return 0; }
function _opt_esc { _opt_ping="'\''"; _opt_qv="${1//\'/$_opt_ping}"; _opt_qv="'${_opt_qv}'"; }
function _opt_push { _opt_dbg "pushing: $@";
    for _opt_i; do _opt_esc "$_opt_i"; _opt_args="${_opt_args}${_opt_qv} "; done; } 
function _opt_value { _opt_dbg _value_; _opt_push "$1"; unset _opt_expect; unset _opt_missing; }
function opt_user_fail { reason="$1"; name="$2"; msg="$3";
    echo >&2 "$msg $name"; exit 1; }
function opt_missing { _opt_dbg _missing_;
    _opt_value "${1:-${_opt_missing:-$_opt_tmissing}}";
    [ $_opt_silent -eq 0 ] && \
        opt_user_fail "missing-value" "$_opt_expect" "error: option expected a value: "; }
function _opt_put {
    if [ -n "$_opt_expect" ]; then [ $_opt_eager -ne 0 ] && _opt_dbg "_eager_" && \
        _opt_value "$_opt_token" && return 0;
        _opt_dbg "_strict_default_"; opt_missing; fi;
    _opt_dbg "_type_: $1"; _opt_push "$2"; [ -n "$3" ] && _opt_value "$3"; }
function opt_invalid { _opt_brk=1;
    _opt_put "i: invalid option" "${1:-$_opt_tinvalid}" "$_opt_token";
    [ $_opt_silent -eq 0 ] &&  \
        opt_user_fail "invalid-option" "$_opt_token" "error: invalid option: "; }
function opt_kv { _opt_put "kv: key value" "$1" "${_opt_token#*=}"; }
function opt_ev { _opt_missing="$2"; _opt_put "ev: expect value option" "$1";
    _opt_expect="$_opt_token"; } 
function opt_v { _opt_put "v: value option"  "$1" "${_opt_token:2}"; }
function opt_vg { _opt_put "vg: value given option"  "$1" "$2"; }
function opt_vs { _opt_put "vs: value suffix" "$1" "${_opt_token#$2}"; }
function opt_f { _opt_put "f: flag option" "$1"; }
function opt_break { [ -n "$_opt_expect" ] && _opt_dbg _break_expecting_ && opt_missing;
    [ $_opt_brk -eq 0 ] && [ -n "$1" ] && _opt_dbg _break_ && _opt_push "$1"; _opt_brk=1; }
function opt_nonopt { opt_break "$1"; _opt_dbg _nonopt_; _opt_push "$_opt_token"; }
function opt_pos { _opt_dbg _pos_; [ -n "$_opt_expect" ] && _opt_value "$_opt_token" \
    || opt_nonopt "$1"; }
function opt_resume { _opt_brk=0; _opt_dbg _resume_; }
function opt_next { _opt_token="$1"; OPT_TOKEN="$1";
    _opt_dbg "args so far: $_opt_args"; _opt_dbg "next token: $1";
    if [ $_opt_brk -eq 0 ]; then return 0; else opt_pos; return 1; fi; }
function opt_get { _opt_tail="$1"; if [ "${1:0:1}" == "-" ] && [ ! $_opt_brk -ne 0 ] &&
    ( [ -z "$_opt_expect" ] || [ $_opt_eager -eq 0 ] ); then 
    while [ "$2" != "${2/${_opt_tail:1:1}/}" ]; do
        _opt_dbg "_combine_: flag '$_opt_tail' in '$2'"
        opt_next "${_opt_tail:0:2}"; opt_f "$OPT_TOKEN"; _opt_tail="-${_opt_tail:2}";
        [ "$_opt_tail" == '-' ] && return 1; done; fi; opt_next "$_opt_tail"; }
function opt_debug { echo >&2 "opt: token='$_opt_token'"; }
function opt_init { _opt_args=""; _opt_token=""; _opt_qv=""; 
    _opt_brk=0; unset _opt_expect; unset OPT_ARGS; _opt_silent=0; _opt_eager=1;
    _opt_tinvalid='?'; _opt_tmissing=':'; _opt_dbg_enabled=0;
    for _opt_i; do _opt_dbg _opt_init_ arg "$_opt_i"
        case "$_opt_i" in silent) _opt_silent=1;; eager) _opt_eager=1;;
    strict) _opt_eager=0;; noisy) _opt_silent=0;; debug) _opt_dbg_enabled=1;;
    invalid=*) _opt_tinvalid=${_opt_i#*=};; missing=*) _opt_tmissing=${_opt_i#*=};;
    *) echo >&2 "error: opt-in opt_init: invalid argument: $_opt_i";; esac; done; }
function opt_final { [ -z "$_opt_expect" ] || opt_missing;
    OPT_ARGS="${_opt_args%?}"; OPT_IN="eval set -- $OPT_ARGS"; _opt_dbg "OPT_ARGS: $OPT_ARGS"
    unset _opt_args; unset _opt_token; unset _opt_qv; unset _opt_silent;unset _opt_debug_enabled;
    unset _opt_eager; unset _opt_tmissing; unset _opt_tinvaild; unset _opt_ping; unset _opt_tail;
    unset opt_i; unset _opt_brk; unset _opt_expect; unset _opt_missing; unset OPT_TOKEN; }
# ------------------------- end opt-in library -------------------------

# ----------------------------------------------------------------------
# opt-in extension library, (c) 2014, Mikkel Fahnøe Jørgensen
# License: MIT
# ----------------------------------------------------------------------
function opt_match_cv {
    # Order is important!
    case "$OPT_TOKEN" in
        "$2") opt_ev "$1" "$3" ;;
        "$1") opt_ev "$1" "$3" ;;
        "$2"=*) opt_kv $1 ;;

        # comment out the following line for getopt compatibility
        "$1"=*) opt_kv $1 ;;
        
        "$1"*) opt_vs "$1" "$1" ;;
            *) return 1 ;;
    esac
    return 0;
}
function opt_match_cf {
    case "$OPT_TOKEN" in
        "$1") opt_f "$1" ;;
        "$2") opt_f "$1" ;;
        *) return 1 ;;
    esac
    return 0;
}
function opt_match_nonoptions {
    case "$OPT_TOKEN" in
        --) opt_break -- ;;
        -*) opt_invalid ;;
        *) opt_pos -- ;;
    esac
    return 0;
}
function opt_user_fail {
    reason=$1; name=$2; msg=$3;
    fail "$msg $name"
}
# -------------------- end opt-in extension library --------------------

function opt_match_lf {
    case "$OPT_TOKEN" in
        "$1") opt_f "$1" ;;
        *) return 1 ;;
    esac
    return 0;
}

opt_init #debug silent
for arg
do
    if opt_get "$arg" "fenvxdht"; then 
        opt_match_cf -f --force      ||
        opt_match_cf -e --export     ||
        opt_match_cf -n --no-headers ||
        opt_match_cf -v --version    ||
        opt_match_cf -t --trace      ||
        opt_match_cf -h --help       ||
        opt_match_cf -d --doc        ||
        opt_match_cf -x --no-expand  ||
        opt_match_cf -g --global     ||
        opt_match_lf --init          ||

        opt_match_cv -s --system     ||
        opt_match_cv -p --profile    ||
        opt_match_cv -o --output     ||
        opt_match_nonoptions
    fi
done
opt_final


# put the translated arguments back on the input
$OPT_IN


# Now do a program specific parse.
# The follwoing will work without the former, but only
# for simple short options like:
#
#    $ rp -h -o <filename> -e -s <system> -p <profiile>
#
# We still keep it tight and keep application logic out, except
# handling implied options. We allow for empty value detection.


# Reset all variables that might be set

unset e_arg
unset f_arg
unset n_arg
unset t_arg
unset x_arg
unset o_arg
unset p_arg
unset s_arg
unset ip_arg
unset exbin_arg

o_val=""
p_val=""
s_val=""

# STDIN (-)
unset stdin_arg
# (--) split operator
unset split_arg

function check_arg {
    if [ $1 -eq 1 ] && ( [ "$2" == ":" ] || [ -z "$2" ] ) ; then
        echo $3;
        echo "aborting."
        exit 1;
    fi
}

function show_version {
    echo "$NAME version $VERSION";
    exit 0;
}

unset OP_TYPE;
unset OP_SRC;
function set_type {
    if [ -z "$OP_TYPE" ]; then
        OP_TYPE=$1
        OP_SRC=$2
    else
        if [ "$OP_TYPE" != $1 ]; then
            fail "flag $OP_SRC incompatible with '$2', aborting";
        fi  
    fi
}

while [ $# -gt 0 ]
do
    case $1 in
        --init) ip_arg=1; set_type init $1 ;;
        -g)  exbin_arg=1; set_type 'run' $1 ;;
        -d)  document set_type doc $1 ;;
        -e)  e_arg=1; set_type 'export' $1 ;;
        -f)  f_arg=1;;
        -h)  help;;
        -n)  n_arg=1; e_arg=1; set_type 'export' $1 ;;
        -t)  t_arg=1;;
        -v)  show_version;;
        -x)  x_arg=1; e_arg=1 set_type 'export' $1 ;;
        -o)  o_arg=1; o_val=$2; set_type 'export' $1; shift;;
        -p)  p_arg=1; p_val=$2; set_type run $1; shift;;
        -s)  s_arg=1; s_val=$2; set_type run $1; shift;;
        --)  shift; break;;
        ?)   echo "invalid option: $2"; shift; break;;
        *) fail "internal: unexpected option or command";;
    esac
    shift
done

# Now the options are fully parsed and the input
# arguments that remain will start with $1.
# cmd_arg will have been set if we got any
# and split_arg will have been set if -- was used.

# Finally pass on the values to application logic.

DEVOPS_EXCLUDE_PROJECT_BIN=$exbin_arg
DEVOPS_INIT_PROJECT=$ip_arg
OVERRIDE_DEVOPS_PROFILE=$p_arg
OVERRIDE_DEVOPS_SYSTEM=$s_arg
DEVOPS_DEBUG=$t_arg
DEVOPS_EXPORT=$e_arg
DEVOPS_OUTPUT=$o_val
DEVOPS_NOEXPAND=$n_arg
DEVOPS_NOHEADERS=$x_arg
DEVOPS_FORCE=$f_arg


OVERRIDE_DEVOPS_PROFILE=${DEVOPS_PROFILE}
OVERRIDE_DEVOPS_SYSTEM=${DEVOPS_SYSTEM}

OP_TYPE=${OP_TYPE:-run}

# missing command, or unknown option
if [ -z "$1" ]; then
    OP=env
    CMD=env
else
    if [ "$OP_TYPE" == run ]; then
        CMD=$@
        OP=$1
    else
        fail "command '$1' not allowed for this type of operation: $OP_TYPE"
    fi
fi


if [ "x$(basename $0)" == "xload_user_env" ]; then
    echo >&2 "source this file before executing a command"
    echo >&2 "see also bin/help load_profile"
    exit 1
fi

function trace
{
    if [ $DEVOPS_DEBUG ]; then
        echo >&2 "trace: $@"
    fi
}

trace "loading profile"

function raw_content
{
    cat $1 | sed '/^\s*$/d'| grep -v ^#
}

function reset_profile_args
{
    PROFILE_ROOT_ARG="{{ profile_root }}"
    PROFILE_HOME_ARG="{{ profile_home }}"
    PROFILE_ARG="{{ profile }}"
}

function reset_system_args
{
    SYSTEM_ROOT_ARG="{{ system_root }}"
    SYSTEM_HOME_ARG="{{ system_home }}"
    SYSTEM_ARG="{{ system }}"
}

# http://unix.stackexchange.com/a/129063
# escaped_rhs=$(printf '%s\n' "$rhs" | sed 's:[\/&]:\\&:g;$!s/$/\\/')

function expanded_content
{
    _prj=$(printf '%s\n' "$PROJECT_HOME_ARG" | sed 's:[\/&]:\\&:g;$!s/$/\\/')
    _pr=$(printf '%s\n' "$PROFILE_ROOT_ARG" | sed 's:[\/&]:\\&:g;$!s/$/\\/')
    _ph=$(printf '%s\n' "$PROFILE_HOME_ARG" | sed 's:[\/&]:\\&:g;$!s/$/\\/')
    _p=$(printf '%s\n' "$PROFILE_ARG" | sed 's:[\/&]:\\&:g;$!s/$/\\/')
    _sr=$(printf '%s\n' "$SYSTEM_ROOT_ARG" | sed 's:[\/&]:\\&:g;$!s/$/\\/')
    _sh=$(printf '%s\n' "$SYSTEM_HOME_ARG" | sed 's:[\/&]:\\&:g;$!s/$/\\/')
    _s=$(printf '%s\n' "$SYSTEM_ARG" | sed 's:[\/&]:\\&:g;$!s/$/\\/')
    cat $1 \
     | sed "s/{{[[:blank:]]*project_home[[:blank:]]*}}/${_prj}/"  \
     | sed "s/{{[[:blank:]]*profile_root[[:blank:]]*}}/${_pr}/"  \
     | sed "s/{{[[:blank:]]*profile_home[[:blank:]]*}}/${_ph}/"  \
     | sed "s/{{[[:blank:]]*profile[[:blank:]]*}}/${_p}/"  \
     | sed "s/{{[[:blank:]]*system_root[[:blank:]]*}}/${_sr}/"  \
     | sed "s/{{[[:blank:]]*system_home[[:blank:]]*}}/${_sh}/"  \
     | sed "s/{{[[:blank:]]*system[[:blank:]]*}}/${_s}/"  \
     | sed '/^[[:blank:]]*$/d' \
     | sed '/^[[:blank:]]*#.*/d' \
     | sed 's/[ \t]*$//'
}

function content
{
    if [ $DEVOPS_NOEXPAND ]; then
        raw_content $1
    else
        expanded_content $1
    fi
}

function dump
{
    if [ $DEVOPS_EXPORT ]; then
        if [ ! $DEVOPS_NOHEADERS ]; then
            echo "[$(basename $1)]"
            content $1
            echo ""
        else
            content $1
        fi
    fi
}

function dump_meta
{
    if [ $DEVOPS_EXPORT ]; then
        if [ ! $DEVOPS_NOHEADERS ]; then
            echo "[meta]"
        fi
        if [ $DEVOPS_NOEXPAND ]; then
            echo "DEVOPS_PROFILE_ROOT={{ profile_root }}"
            echo "DEVOPS_PROFILE_HOME={{ profile_home }}"
        else
            echo "DEVOPS_PROFILE_ROOT=${DEVOPS_PROFILE_ROOT}"
            echo "DEVOPS_PROFILE_HOME=${DEVOPS_PROFILE_HOME}"
        fi
        echo "DEVOPS_PROFILE=${DEVOPS_PROFILE}"
        if [ $DEVOPS_NOEXPAND ]; then
            echo "DEVOPS_SYSTEM_ROOT={{ system_root }}"
            echo "DEVOPS_SYSTEM_HOME={{ system_home }}"
        else
            echo "DEVOPS_SYSTEM_ROOT=${DEVOPS_SYSTEM_ROOT}"
            echo "DEVOPS_SYSTEM_HOME=${DEVOPS_SYSTEM_HOME}"
        fi
        echo "DEVOPS_SYSTEM=${DEVOPS_SYSTEM}"
    fi
}

function process
{
    if [ -e "$1" ]; then
        trace "processing: $1"
        set -e
        if [ -n "$DEVOPS_OUTPUT" ]; then
            dump $1 > $DEVOPS_OUTPUT
        else
            dump $1
        fi

        # We need to find DEVOPS_PROFILE or DEVOPS_SYSTEM, even if we only export
        # the following xargs solution is elegant, but breaks on spaces, even quoted.
        # export  $(expanded_content $1 | xargs )
        # other solutions break because export must not be in a subshell
        # the following works ... sigh
        old_IFS=$IFS; IFS=$'\n'

        for line in $(expanded_content $1); do export "$line"; done 
        IFS=$old_IFS
        [ -z "$DEVOPS_PROFILE_HOME" ] || echo >&2 "warning: DEVOPS_PROFILE_HOME canot be set in $(basename $1)\n- it is a computed value"
        [ -z "$DEVOPS_SYSTEM_HOME" ] || echo >&2 "warning: DEVOPS_SYSTEM_HOME can never set in $(basename $1)\n- it is a computed value"
    else
        trace "skipping: $1"
    fi
}

# for now we just use .devops.conf as an anchor without
# reading it, and assume systems root is relative to
# that location if found, or current path otherwise.
function load_project_config
{
    unset PROJECT_CONFIG
    PROJECT_HOME=$(pwd);
    DEFAULT_SYSTEM_ROOT="$(pwd)/systems";
    DEFAULT_PROFILE_ROOT="${HOME}/.devops/profiles" 
    SEARCH_PATH=$(pwd)
    trace "searching current and parent dirs for devops.conf"
    while [ -n "$SEARCH_PATH" ]; do
        if [ -e "${SEARCH_PATH}/.devops.conf" ]; then
            PROJECT_CONFIG="$SEARCH_PATH/.devops.conf"
            PROJECT_HOME="$SEARCH_PATH"
            DEFAULT_SYSTEM_ROOT="${PROJECT_HOME}/systems"
            trace "project home found: ${PROJECT_HOME}"
            return;
        fi; 
        if [ "$SEARCH_PATH" == "/" ]; then break; fi
        SEARCH_PATH=$(dirname "$SEARCH_PATH");
    done
    trace "project home not found, using current directory"
}

function check
{
    option="$1=$2"
    trace $option
    if [ ! -d $2 ]; then
        echo >&2 "error: expected a directory: $2"
        if [ ! $DEVOPS_FORCE ]; then
            echo >&2 "... aborting"
            exit 1
        fi
        trace "force flag overrides error, continuing"
    fi
}


# In general values are set by the user in the environment,
# but all values can be set in a subshell of the profiled
# environment. In this case the settings in .env files
# will not be active. While an accidental implication,
# it also seems the best thing to do.


load_project_config

if [ $DEVOPS_INIT_PROJECT ]; then
    if [ -z "$PROJECT_CONFIG" ]; then
        echo "creating project"
        mkdir -p systems || fail "could not create systems directory"
        trace "creating systems directory if it doesn't exist"
        trace "creating .devops.conf file to mark project location"
        touch .devops.conf
        if [ ! -e systems/common_system.env ]; then
            trace "creating systems/common_system.env"
            touch systems/common_system.env
        else
            trace "systems/common/system.env already exists, skipping"
        fi
    else
        echo "skipping since '.devops.conf' already exists at:"
        echo "  $PROJECT_CONFIG"
        exit 1;
    fi
    exit 0;
fi

# Pick up from environment unless command line already overrides.
OVERRIDE_DEVOPS_PROFILE_ROOT=${OVERRIDE_DEVOPS_PROFILE_ROOT:-${DEVOPS_PROFILE_ROOT:-""}}
OVERRIDE_DEVOPS_PROFILE=${OVERRIDE_DEVOPS_PROFILE:-${DEVOPS_PROFILE:-""}}
OVERRIDE_DEVOPS_SYSTEM=${OVERRIDE_DEVOPS_SYSTEM:-${DEVOPS_SYSTEM:-""}}
OVERRIDE_DEVOPS_SYSTEM_ROOT=${OVERRIDE_DEVOPS_SYSTEM_ROOT:-${DEVOPS_SYSTEM_ROOT:-""}}

unset DEVOPS_PROFILE_ROOT
unset DEVOPS_PROFILE_HOME
unset DEVOPS_PROFILE
unset DEVOPS_SYSTEM_ROOT
unset DEVOPS_SYSTEM_HOME
unset DEVOPS_SYSTEM

reset_profile_args
reset_system_args

# Project home is always defined, either current directory
# or the ancestor with a '.devops.conf' filei, and cannot
# be set. May be used to set system root as relative path.
PROJECT_HOME_ARG="$PROJECT_HOME"


OVERRIDE_DEVOPS_PROFILE_ROOT=${OVERRIDE_DEVOPS_PROFILE_ROOT:-${DEFAULT_PROFILE_ROOT}}
check DEVOPS_PROFILE_ROOT ${OVERRIDE_DEVOPS_PROFILE_ROOT}
PROFILE_ROOT_ARG=${OVERRIDE_DEVOPS_PROFILE_ROOT}
process "${OVERRIDE_DEVOPS_PROFILE_ROOT}/common_profile.env"

[ -z "$DEVOPS_SYSTEM" ] || echo >&2 "warning: DEVOPS_SYSTEM cannot be set in 'common_profile.env'"
OVERRIDE_DEVOPS_PROFILE=${OVERRIDE_DEVOPS_PROFILE:-${DEVOPS_PROFILE}}
OVERRIDE_DEVOPS_SYSTEM=${OVERRIDE_DEVOPS_SYSTEM:-${DEVOPS_SYSTEM}}
OVERRIDE_DEVOPS_SYSTEM_ROOT=${OVERRIDE_DEVOPS_SYSTEM_ROOT:-${DEVOPS_SYSTEM_ROOT}}
unset DEVOPS_PROFILE
unset DEVOPS_SYSTEM
unset DEVOPS_SYSTEM_ROOT

trace "DEVOPS_PROFILE=${OVERRIDE_DEVOPS_PROFILE}"
sep=""
[ -z "$OVERRIDE_DEVOPS_PROFILE" ] || sep="/"
OVERRIDE_DEVOPS_PROFILE_HOME=${OVERRIDE_DEVOPS_PROFILE_ROOT}${sep}${OVERRIDE_DEVOPS_PROFILE}
check DEVOPS_PROFILE_HOME ${OVERRIDE_DEVOPS_PROFILE_HOME}
PROFILE_HOME_ARG=${OVERRIDE_DEVOPS_PROFILE_HOME}
PROFILE_ARG=${OVERRIDE_DEVOPS_PROFILE}
process "${OVERRIDE_DEVOPS_PROFILE_HOME}/profile.env"

[ -z "$DEVOPS_PROFILE_ROOT" ] || echo >&2 "warning: DEVOPS_PROFILE_ROOT cannot be set in 'profile.env'"
[ -z "$DEVOPS_PROFILE" ] || echo >&2 "warning: DEVOPS_PROFILE cannot be set in 'profile.env'"
OVERRIDE_DEVOPS_SYSTEM_ROOT=${OVERRIDE_DEVOPS_SYSTEM_ROOT:-${DEVOPS_SYSTEM_ROOT}}
OVERRIDE_DEVOPS_SYSTEM=${OVERRIDE_DEVOPS_SYSTEM:-${DEVOPS_SYSTEM}}
unset DEVOPS_SYSTEM_ROOT
unset DEVOPS_SYSTEM

# profile args are decoupled from system configuration directly
reset_profile_args

OVERRIDE_DEVOPS_SYSTEM_ROOT=${OVERRIDE_DEVOPS_SYSTEM_ROOT:-${DEFAULT_SYSTEM_ROOT}}
check DEVOPS_SYSTEM_ROOT ${OVERRIDE_DEVOPS_SYSTEM_ROOT}
SYSTEM_ROOT_ARG=${OVERRIDE_DEVOPS_SYSTEM_ROOT}
process ${OVERRIDE_DEVOPS_SYSTEM_ROOT}/common_system.env


[ -z "$DEVOPS_PROFILE" ] || echo >&2 "warning: DEVOPS_PROFILE cannot be set in 'common_system.env'"
[ -z "$DEVOPS_PROFILE_ROOT" ] || echo >&2 "warning: DEVOPS_PROFILE_ROOT cannot be set in 'common_system.env'"
[ -z "$DEVOPS_SYSTEM_ROOT" ] || echo >&2 "warning: DEVOPS_SYSTEM_ROOT cannot be set in 'common_system.env'"
[ -z "$DEVOPS_PROFILE" ] || echo >&2 "warning: DEVOPS_PROFILE cannot be set in 'common_system.env'"

# Allow system to be selected in common_profile.env.
OVERRIDE_DEVOPS_SYSTEM=${OVERRIDE_DEVOPS_SYSTEM:-${DEVOPS_SYSTEM}}
unset DEVOPS_SYSTEM

sep=""
[ -z "$OVERRIDE_DEVOPS_SYSTEM" ] || sep="/"
trace "DEVOPS_PROFILE=${OVERRIDE_DEVOPS_PROFILE}"
OVERRIDE_DEVOPS_SYSTEM_HOME=${OVERRIDE_DEVOPS_SYSTEM_ROOT}${sep}${OVERRIDE_DEVOPS_SYSTEM}
check DEVOPS_SYSTEM_HOME ${OVERRIDE_DEVOPS_SYSTEM_HOME}
SYSTEM_HOME_ARG=${OVERRIDE_DEVOPS_SYSTEM_HOME}
SYSTEM_ARG=${OVERRIDE_DEVOPS_SYSTEM}
process ${OVERRIDE_DEVOPS_SYSTEM_HOME}/system.env

[ -z "$DEVOPS_PROFILE_ROOT" ] || echo >&2 "warning: DEVOPS_PROFILE_ROOT cannot be set in 'system.env'"
[ -z "$DEVOPS_SYSTEM_ROOT" ] || echo >&2 "warning: DEVOPS_SYSTEM_ROOT cannot be set in 'system.env'"
[ -z "$DEVOPS_PROFILE" ] || echo >&2 "warning: DEVOPS_PROFILE cannot be set in 'system.env'"
[ -z "$DEVOPS_SYSTEM" ] || echo >&2 "warning: DEVOPS_SYSTEM cannot be set in 'system.env'"


export DEVOPS_PROFILE_ROOT=${OVERRIDE_DEVOPS_PROFILE_ROOT}
export DEVOPS_PROFILE_HOME=${OVERRIDE_DEVOPS_PROFILE_HOME}
export DEVOPS_PROFILE=${OVERRIDE_DEVOPS_PROFILE}
export DEVOPS_SYSTEM_ROOT=${OVERRIDE_DEVOPS_SYSTEM_ROOT}
export DEVOPS_SYSTEM_HOME=${OVERRIDE_DEVOPS_SYSTEM_HOME}
export DEVOPS_SYSTEM=${OVERRIDE_DEVOPS_SYSTEM}
export DEVOPS_PROJECT_HOME=${PROJECT_HOME}

if [ -n "$DEVOPS_OUTPUT" ]; then
    dump_meta > $DEVOPS_OUTPUT
else
    dump_meta
fi

function check_cmd {
    # this method is Posix compliant.
    command -v $1 >/dev/null 2>&1
}

if [ "$OP_TYPE" == "run" ]; then
    if [ $DEVOPS_EXCLUDE_PROJECT_BIN ]; then
        trace "ignoring project bin path due to exclusion flag"
    else
        # Allow specific systems to provide scripts and to override project defaults.
        # We do no support system root bin path, that would get a bit excessive.
        if [ "$DEVOPS_SYSTEM_ROOT" != "$DEVOPS_SYSTEM_HOME" ] &&
            [ -d "${DEVOPS_SYSTEM_ROOT}/bin" ]; then
            trace "extending PATH variable with: ${DEVOPS_SYSTEM_ROOT}/bin"
            export PATH="$DEVOPS_SYSTEM_ROOT/bin:$PATH"
        else
            trace "no {{ system_root }}/bin found, skipping path extension"
        fi
        if [ -d "${DEVOPS_SYSTEM_HOME}/bin" ]; then
            trace "extending PATH variable with: ${DEVOPS_SYSTEM_HOME}/bin"
            export PATH="$DEVOPS_SYSTEM_HOME/bin:$PATH"
        else
            trace "no {{ system_home }}/bin found, skipping path extension"
        fi
    fi
    check_cmd "$OP" || fail "error: command not found: $OP"
    trace "executing: $CMD"
    $CMD
fi

